package betterterrain.biome.layer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import betterterrain.biome.BTABiome;
import betterterrain.biome.BiomeConfiguration;
import betterterrain.biome.Climate;
import net.minecraft.src.GenLayer;
import net.minecraft.src.IntCache;

public class ClimatesLayer extends BTALayer {
	private ArrayList<BTABiome> biomesForGeneration;
	private Map<Climate, ArrayList<BTABiome>> biomeCategoryMapCached = new HashMap();
	private ArrayList<Integer> climateIDsForGeneration = new ArrayList();

	public ClimatesLayer(long baseSeed, GenLayer parent, ArrayList<BTABiome> biomesForGeneration) {
		super(baseSeed);
		this.parent = parent;
		this.biomesForGeneration = biomesForGeneration;

		for (Climate c : Climate.values()) {
			if (c.isOverworld) {
				this.biomeCategoryMapCached.put(c, BiomeConfiguration.getClimateListForGenerator(c, this.biomesForGeneration));

				if (biomeCategoryMapCached.get(c).size() != 0) {
					climateIDsForGeneration.add(c.id);
				}
			}
		}
	}

	/**
	 * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
	 * amounts, or biomeList[] indices based on the particular GenLayer subclass.
	 */
	public int[] getInts(int xOffset, int zOffset, int sizeX, int sizeZ) {
		int parentXOffset = xOffset - 1;
		int parentZOffset = zOffset - 1;
		int parentSizeX = sizeX + 2;
		int parentSizeZ = sizeZ + 2;
		int[] parentArray = this.parent.getInts(parentXOffset, parentZOffset, parentSizeX, parentSizeZ);
		int[] cache = IntCache.getIntCache(sizeX * sizeZ);

		for (int i = 0; i < sizeZ; ++i) {
			for (int k = 0; k < sizeX; ++k) {
				int parentInt = parentArray[k + 1 + (i + 1) * parentSizeX];
				this.initChunkSeed((long)(k + xOffset), (long)(i + zOffset));

				int climateID = climateIDsForGeneration.get(this.nextInt(climateIDsForGeneration.size()));

				cache[k + i * sizeX] = climateID;
			}
		}

		return cache;
	}
}
